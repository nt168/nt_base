diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..70e174eff2fa295ec6fa59021ca5cbeaa6ab5b16
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,47 @@
+CC := gcc
+SRCS := common.c fatal.c nt_log.c nt_mutexs.c nt_phreads.c nt_base.c version.c
+
+WARNINGS := -Wall -Wextra
+CSTD := -std=c11
+
+CPPFLAGS := -I.
+CFLAGS := $(CSTD) $(WARNINGS) -pthread
+LDFLAGS := -pthread
+
+CONFIG ?= Release
+BUILD_ROOT ?= build
+BUILD_ROOT := $(abspath $(BUILD_ROOT))
+OUT_DIR := $(BUILD_ROOT)/$(CONFIG)
+
+ifeq ($(CONFIG),Debug)
+  CFLAGS += -g -O0 -DDEBUG
+else
+  CFLAGS += -O2
+endif
+
+TARGET := $(OUT_DIR)/nt_base
+LIB := $(OUT_DIR)/libnt.a
+OBJECTS := $(addprefix $(OUT_DIR)/,$(SRCS:.c=.o))
+LIB_OBJECTS := $(filter-out $(OUT_DIR)/nt_base.o,$(OBJECTS))
+
+.PHONY: all clean comms
+
+all: $(TARGET) comms
+
+$(OUT_DIR):
+	mkdir -p $(OUT_DIR)
+
+$(OUT_DIR)/%.o: %.c | $(OUT_DIR)
+	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@
+
+$(LIB): $(LIB_OBJECTS)
+	ar rcs $@ $^
+
+$(TARGET): $(LIB) $(OUT_DIR)/nt_base.o
+	$(CC) $(CFLAGS) $(OUT_DIR)/nt_base.o $(LIB) -o $@
+
+comms: $(OUT_DIR)
+	$(MAKE) -C comms BUILD_ROOT=$(BUILD_ROOT) CONFIG=$(CONFIG)
+
+clean:
+	rm -rf $(BUILD_ROOT)
diff --git a/common.h b/common.h
index 9780e90343b5422bb84b161a096d68bbcc3ad289..a067222f91ada150995b1997ba3fe0b186d54064 100644
--- a/common.h
+++ b/common.h
@@ -1,41 +1,50 @@
 #ifndef COMMON_H
 #define COMMON_H
 
+#ifndef _DEFAULT_SOURCE
+#define _DEFAULT_SOURCE
+#endif
+
+#ifndef _POSIX_C_SOURCE
+#define _POSIX_C_SOURCE 200809L
+#endif
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
 
 #include <errno.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <signal.h>
 #include <syslog.h>
 #include <sys/ipc.h>
 #include <sys/shm.h>
 #include <sys/sem.h>
 #include <string.h>
+#include <sys/time.h>
 #include <assert.h>
 #include <semaphore.h>
 #include <time.h>
 #include <pwd.h>
 
 #include <pthread.h>
 #include <sys/types.h>
 
 #include <sys/wait.h>
 #include <sys/stat.h>
 
 #include "nt_types.h"
 
 #define SEM_SERVER_RUN "/sem_server_run"
 #define SEM_QTWINDOW_RUN "/sem_qtwindow_run"
 
 #define	SUCCEED		0
 #define	FAIL		-1
 
 #define LEVEL_WARNING	3
 #define LEVEL_DEBUG		4
 
 #define PHRASE 100
 #define MAX_STRING_LEN		2048
 #define MAX_BUFFER_LEN		65536
diff --git a/comms/Makefile b/comms/Makefile
index 721e5019d1520c20b1e7fb63ed7cff8023f30572..fcfcfc1599722362af817e5ae3035c14d54c62c1 100644
--- a/comms/Makefile
+++ b/comms/Makefile
@@ -1,53 +1,71 @@
 CC      := gcc
-CFLAGS  := -Wall -Wextra -g -O2 -I. -I..
+WARNINGS := -Wall -Wextra
+CSTD    := -std=c11
+
+CONFIG ?= Release
+BUILD_ROOT ?= $(abspath ../build)
+OUT_DIR := $(BUILD_ROOT)/$(CONFIG)/comms
+
+CPPFLAGS := -I. -I..
+CFLAGS  := $(CSTD) $(WARNINGS) -pthread
 LDFLAGS := -lpthread
 
-TARGET  := main
+ifeq ($(CONFIG),Debug)
+  CFLAGS += -g -O0 -DDEBUG
+else
+  CFLAGS += -O2
+endif
+
+TARGET  := $(OUT_DIR)/comms
 
 # comms 子目录里的源码
 COMMS_SRCS := \
     base64.c \
     comms.c  \
     crypto.c \
     ip.c     \
     md5.c    \
     nt_hash.c \
     nt_num.c \
     nt_str.c \
     nt_time.c \
     iprange.c \
     misc.c    \
     compress.c \
     endian.c   \
     common_log.c \
     common_str.c \
     components_strings_representations.c \
     sha256crypto.c
 
 # 上级 nt_base 中需要的基础组件（提供 nt_log / nt_malloc / 线程与锁等）
 NT_BASE_SRCS := \
     ../common.c \
     ../fatal.c  \
     ../nt_log.c \
     ../nt_mutexs.c \
     ../nt_phreads.c
 
 SRCS := $(COMMS_SRCS) $(NT_BASE_SRCS) main.c
+OBJS := $(addprefix $(OUT_DIR)/,$(notdir $(SRCS:.c=.o)))
 
-OBJS := $(SRCS:.c=.o)
+VPATH := . ..
 
 .PHONY: all clean
 
 all: $(TARGET)
 
-$(TARGET): $(OBJS)
+$(OUT_DIR):
+	mkdir -p $(OUT_DIR)
+
+$(TARGET): $(OBJS) | $(OUT_DIR)
 	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LDFLAGS)
 
-%.o: %.c
-	$(CC) $(CFLAGS) -c $< -o $@
+$(OUT_DIR)/%.o: %.c | $(OUT_DIR)
+	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@
 
-../%.o: ../%.c
-	$(CC) $(CFLAGS) -c $< -o $@
+$(OUT_DIR)/%.o: ../%.c | $(OUT_DIR)
+	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@
 
 clean:
-	rm -f $(OBJS) $(TARGET)
+	rm -rf $(BUILD_ROOT)
diff --git a/comms/common_log.c b/comms/common_log.c
index b3a1519eff46a51739de3b84fdeb0c0a6fffb6b7..c59461ce28df71c299432423ec6414414ad3ff31 100644
--- a/comms/common_log.c
+++ b/comms/common_log.c
@@ -1,55 +1,62 @@
 #include "nt_common.h"
 
 typedef void		(*nt_backtrace_f)(void);
 
 #define LOG_LEVEL_DEC_FAIL	-2
 #define LOG_LEVEL_DEC_SUCCEED	-1
 #define LOG_LEVEL_UNCHANGED	0
 #define LOG_LEVEL_INC_SUCCEED	1
 #define LOG_LEVEL_INC_FAIL	2
 
 // static int			log_level = LOG_LEVEL_WARNING;
 // static NT_THREAD_LOCAL int	*plog_level = &log_level;
 // static nt_log_func_t		log_func_callback = NULL;
 // static nt_get_progname_f	get_progname_cb = NULL;
 static nt_backtrace_f		backtrace_cb = NULL;
 
 #define LOG_COMPONENT_NAME_LEN	64
 static NT_THREAD_LOCAL int	log_level_change = LOG_LEVEL_UNCHANGED;
 static NT_THREAD_LOCAL char	log_component_name[LOG_COMPONENT_NAME_LEN + 1];
 #undef LOG_COMPONENT_NAME_LEN
 
+static void nt_common_log_silence_unused(void)
+{
+	NT_UNUSED(log_level_change);
+	NT_UNUSED(log_component_name);
+}
+
 // void	nt_init_library_common(nt_log_func_t log_func, nt_get_progname_f get_progname, nt_backtrace_f backtrace)
 // {
 // 	log_func_callback = log_func;
 // 	get_progname_cb = get_progname;
 // 	backtrace_cb = backtrace;
 // }
 
 void	nt_this_should_never_happen_backtrace(void)
 {
+	nt_common_log_silence_unused();
 	if (NULL != backtrace_cb)
 		backtrace_cb();
 }
 
 // void	nt_log_handle(int level, const char *fmt, ...)
 // {
 // 	va_list args;
 
 // 	va_start(args, fmt);
 // 	log_func_callback(level, fmt, args);
 // 	va_end(args);
 // }
 
 // int	nt_get_log_level(void)
 // {
 // 	return *plog_level;
 // }
 
 // void	nt_set_log_level(int level)
 // {
 // 	log_level = level;
 // }
 
 // const char	*nt_get_log_component_name(void)
 // {
diff --git a/comms/comms.c b/comms/comms.c
index f072fcd6513dc79afe78575c1b4b587abf6f6272..ce8251c387133f18e141f3c7f34478df20776f45 100644
--- a/comms/comms.c
+++ b/comms/comms.c
@@ -1,40 +1,41 @@
 #include "comms.h"
 #include "nt_comms.h"
 #include "nt_common.h"
 
 #if defined(HAVE_GNUTLS) || defined(HAVE_OPENSSL)
 #include "tls.h"
 #endif
 #include "nt_log.h"
 #include "nt_compress.h"
 #include "nt_str.h"
 #include "nt_num.h"
 #include "nt_ip.h"
 #include "nt_time.h"
 #include "nt_crypto.h"
 #include "../nt_types.h"
+#include <netdb.h>
 
 #ifdef _WINDOWS
 #	ifndef _WIN32_WINNT_WIN7
 #		define _WIN32_WINNT_WIN7		0x0601	/* allow compilation on older Windows systems */
 #	endif
 #	ifndef WSA_FLAG_NO_HANDLE_INHERIT
 #		define WSA_FLAG_NO_HANDLE_INHERIT	0x80	/* allow compilation on older Windows systems */
 #	endif
 #endif
 
 #ifndef NT_SOCKLEN_T
 #	define NT_SOCKLEN_T socklen_t
 #endif
 
 #ifndef SOCK_CLOEXEC
 #	define SOCK_CLOEXEC 0	/* SOCK_CLOEXEC is Linux-specific, available since 2.6.23 */
 #endif
 
 static int	socket_set_nonblocking(NT_SOCKET s);
 static void	tcp_set_socket_strerror_from_getaddrinfo(const char *ip);
 static ssize_t	tcp_read(nt_socket_t *s, char *buffer, size_t size, short *events);
 
 nt_config_tls_t	*nt_config_tls_new(void)
 {
 	nt_config_tls_t	*config_tls;
diff --git a/comms/nt_common.h b/comms/nt_common.h
index f18a56e2fadf2018078205ead234c0e7234e97bc..5646402765b6338defe0dd492471adcb069def59 100644
--- a/comms/nt_common.h
+++ b/comms/nt_common.h
@@ -27,50 +27,57 @@
 
 #define MAX_ID_LEN			21
 #define MAX_STRING_LEN			2048
 #define MAX_BUFFER_LEN			65536
 #define NT_MAX_HOSTNAME_LEN		128
 #define NT_HOSTNAME_BUF_LEN	(NT_MAX_HOSTNAME_LEN + 1)
 #define NT_MAX_DNSNAME_LEN		255	/* maximum host DNS name length from RFC 1035 */
 						/*(without terminating '\0') */
 #define MAX_EXECUTE_OUTPUT_LEN		(16 * NT_MEBIBYTE)
 
 #define NT_MAX_UINT64		(~__UINT64_C(0))
 #define NT_MAX_UINT64_LEN	21
 #define NT_MAX_UINT32_LEN	11
 #define NT_MAX_DOUBLE_LEN	24
 
 #define NT_SIZE_T_MAX	(~(size_t)0)
 
 #define NT_MALLOC_TRIM (128 * NT_KIBIBYTE)
 
 #define HOST_TLS_SUBJECT_LEN		4096				/* for up to 1024 UTF-8 characters */
 #define HOST_TLS_SUBJECT_LEN_MAX	(HOST_TLS_SUBJECT_LEN + 1)
 
 #define HOST_TLS_ISSUER_LEN             4096                            /* for up to 1024 UTF-8 characters */
 #define HOST_TLS_ISSUER_LEN_MAX         (HOST_TLS_ISSUER_LEN + 1)
 
+/* commonly used helpers */
+void    nt_snprintf_alloc(char **str, size_t *alloc_len, size_t *offset, const char *fmt, ...);
+int     nt_validate_hostname(const char *hostname);
+const char      *nt_result_string(int result);
+nt_uint64_t      suffix2factor(char c);
+void            nt_this_should_never_happen_backtrace(void);
+
 #if defined(__GNUC__) && __GNUC__ >= 7
 #	define NT_FALLTHROUGH	__attribute__ ((fallthrough))
 #else
 #	define NT_FALLTHROUGH
 #endif
 #define NT_JAN_1970_IN_SEC	2208988800.0	/* 1970 - 1900 in seconds */
 #define NT_LENGTH_UNLIMITED	0x7fffffff
 
 #endif /* NT_COMMON_H */
 
 
 #if 0
 #ifndef NT_COMMON_H
 #define NT_COMMON_H
 
 // #include "ntsysinc.h"
 // #include "module.h"
 // #include "version.h"
 
 #if defined(__MINGW32__)
 #	define __try
 #	define __except(x) if (0)
 #endif
 
 #ifndef va_copy
diff --git a/comms/nt_comms.h b/comms/nt_comms.h
index bb645f7ba0808ca8ba80c1ca08250dbc4a1d88cd..b99d53d59200887d859247fe9e84ce9b632d2fcd 100644
--- a/comms/nt_comms.h
+++ b/comms/nt_comms.h
@@ -1,41 +1,43 @@
 #ifndef NT_COMMS_H
 #define NT_COMMS_H
 
 //#include "nt_algo.h"
 #include "nt_common.h"
 #include "nt_comms.h"
 #include "nt_time.h"
 
 /* 先引入系统 socket 相关头文件（Linux/Unix 路径） */
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netdb.h>        /* struct addrinfo, getaddrinfo, getnameinfo, NI_* */
 #include <netinet/in.h>   /* struct sockaddr_in, sockaddr_in6, IPPROTO_TCP 等 */
 #include <arpa/inet.h>    /* inet_pton, inet_ntop, inet_ntoa */
 #include <poll.h>         /* struct pollfd, POLLIN, POLLOUT, POLLERR... */
 
+struct addrinfo;
+
 
 
 
 #define NT_IPV4_MAX_CIDR_PREFIX	32	/* max number of bits in IPv4 CIDR prefix */
 #define NT_IPV6_MAX_CIDR_PREFIX	128	/* max number of bits in IPv6 CIDR prefix */
 
 #ifdef _WINDOWS
 #	define nt_socket_last_error()		WSAGetLastError()
 
 #	define NT_PROTO_ERROR			SOCKET_ERROR
 #	define NT_SOCKET_TO_INT(s)		((int)(s))
 #else
 #	define nt_socket_last_error()		errno
 
 #	define NT_PROTO_ERROR		-1
 #	define NT_SOCKET_TO_INT(s)	(s)
 #endif
 
 #ifdef _WINDOWS
 #	if !defined(POLLIN)
 #		define POLLIN	0x001
 #	endif
 #	if !defined(POLLPRI)
 #		define POLLPRI	0x002
 #	endif
diff --git a/comms/nt_num.h b/comms/nt_num.h
index c4b99a78dc0cee8597b7481b3612ae35e7215c0a..4b34e43051752eb101efc9edc86ab9f5f8323c7a 100644
--- a/comms/nt_num.h
+++ b/comms/nt_num.h
@@ -32,32 +32,34 @@ int	nt_is_int(const char *str, int *value);
 int	nt_is_hex_n_range(const char *str, size_t n, void *value, size_t size, nt_uint64_t min, nt_uint64_t max);
 int	nt_is_hex_string(const char *str);
 
 double	nt_get_float_epsilon(void);
 double	nt_get_double_epsilon(void);
 void	nt_update_epsilon_to_float_precision(void);
 void	nt_update_epsilon_to_python_compatible_precision(void);
 int	nt_double_compare(double a, double b);
 int	nt_validate_value_dbl(double value);
 
 int	nt_int_in_list(char *list, int value);
 
 #define NT_UNIT_SYMBOLS	"KMGTsmhdw"
 
 #define NT_FLAG_DOUBLE_PLAIN	0x00
 #define NT_FLAG_DOUBLE_SUFFIX	0x01
 int	nt_is_double(const char *str, double *value);
 
 #if defined(_WINDOWS) || defined(__MINGW32__)
 int	nt_wis_uint(const wchar_t *wide_string);
 #endif
 
 const char	*nt_print_double(char *buffer, size_t size, double val);
 int		nt_number_parse(const char *number, int *len);
 
+#ifndef NT_STR2UINT64
 #define NT_STR2UINT64(uint, string) nt_is_uint64(string, &uint)
+#endif
 
 int	nt_str2uint64(const char *str, const char *suffixes, nt_uint64_t *value);
 
 void	nt_trim_integer(char *str);
 void	nt_trim_float(char *str);
 #endif /* NT_NUM_H */
diff --git a/fatal.c b/fatal.c
index 0cac4779eb235b85f4fc5a6537e59866f8ce633d..d68137dead4055fb4d078ec45c2a065df1cbc05c 100644
--- a/fatal.c
+++ b/fatal.c
@@ -55,50 +55,52 @@ void	nt_backtrace(void)
 
 	bcktrc_sz = backtrace(bcktrc, NT_BACKTRACE_SIZE);
 	bcktrc_syms = backtrace_symbols(bcktrc, bcktrc_sz);
 
 	if (NULL == bcktrc_syms)
 	{
 		nt_log(LOG_LEVEL_CRIT, "error in backtrace_symbols(): %s", nt_strerror(errno));
 
 		for (i = 0; i < bcktrc_sz; i++)
 			nt_log(LOG_LEVEL_CRIT, "%d: %p", bcktrc_sz - i - 1, bcktrc[i]);
 	}
 	else
 	{
 		for (i = 0; i < bcktrc_sz; i++)
 			nt_log(LOG_LEVEL_CRIT, "%d: %s", bcktrc_sz - i - 1, bcktrc_syms[i]);
 
 		nt_free(bcktrc_syms);
 	}
 #else
 	nt_log(LOG_LEVEL_CRIT, "backtrace is not available for this platform");
 #endif	/* HAVE_EXECINFO_H */
 }
 
 void	nt_log_fatal_info(void *context, unsigned int flags)
 {
+
+        NT_UNUSED(context);
 #ifdef	HAVE_SYS_UCONTEXT_H
 
 #if defined(REG_EIP) || defined(REG_RIP)
 	ucontext_t	*uctx = (ucontext_t *)context;
 #endif
 
 	/* look for GET_PC() macro in sigcontextinfo.h files */
 	/* of glibc if you wish to add more CPU architectures */
 
 #	if	defined(REG_EIP)	/* i386 */
 
 #		define NT_GET_REG(uctx, reg)	(uctx)->uc_mcontext.gregs[reg]
 #		define NT_GET_PC(uctx)		NT_GET_REG(uctx, REG_EIP)
 
 #	elif	defined(REG_RIP)	/* x86_64 */
 
 #		define NT_GET_REG(uctx, reg)	(uctx)->uc_mcontext.gregs[reg]
 #		define NT_GET_PC(uctx)		NT_GET_REG(uctx, REG_RIP)
 
 #	endif
 
 #endif	/* HAVE_SYS_UCONTEXT_H */
 //	int	i;
 	FILE	*fd;
 
diff --git a/nt_phreads.c b/nt_phreads.c
index cd19a278f94546ef8250c432269d364dd6bc1776..55bcaf194597cffcdf138702f41384723cdfe4ba 100644
--- a/nt_phreads.c
+++ b/nt_phreads.c
@@ -68,50 +68,51 @@ int	nt_child_fork()
 	return pid;
 }
 #endif
 
 #if 1
 NT_THREAD_HANDLE nt_thread_start(NT_THREAD_ENTRY_POINTER(handler), nt_thread_args_t *thread_args)
 {
 	NT_THREAD_HANDLE	thread = NT_THREAD_HANDLE_NULL;
 	if (0 == (thread = nt_child_fork()))	/* child process */
 	{
 		(*handler)(thread_args);
 		nt_thread_exit(EXIT_SUCCESS);
 	}
 	else if (-1 == thread)
 	{
 		nt_error("failed to fork: %s", nt_strerror(errno));
 		thread = (NT_THREAD_HANDLE)NT_THREAD_ERROR;
 	}
 	return thread;
 }
 #endif
 
 
 int	MAIN_SERVER_ENTRY(int flags)
 {
+        NT_UNUSED(flags);
 //	nt_thread_start(nt_net_server, NULL);
 //	nt_thread_start(messagechannel, NULL);
 //	nt_thread_start(agents_synchronizer, NULL);
 
 	return 0;
 }
 
 
 void nt_tls_free_on_signal(void)
 {
 	if (NULL != my_psk)
 		nt_guaranteed_memset(my_psk, 0, my_psk_len);
 }
 
 int	create_pid_file(const char *pidfile)
 {
 	int		fd;
 	nt_stat_t	buf;
 	struct flock	fl;
 
 	fl.l_type = F_WRLCK;
 	fl.l_whence = SEEK_SET;
 	fl.l_start = 0;
 	fl.l_len = 0;
 	fl.l_pid = getpid();
@@ -301,50 +302,53 @@ void	terminate_signal_handler(int sig, siginfo_t *siginfo, void *context)
 					sig, get_signal_name(sig),
 					SIG_CHECKED_FIELD(siginfo, si_pid),
 					SIG_CHECKED_FIELD(siginfo, si_uid),
 					SIG_CHECKED_FIELD(siginfo, si_code));
 
 #if defined(HAVE_POLARSSL) || defined(HAVE_GNUTLS) || defined(HAVE_OPENSSL)
 			nt_tls_free_on_signal();
 #endif
 			nt_on_exit();
 		}
 	}
 }
 
 void log_fatal_signal(int sig, siginfo_t *siginfo, void *context)
 {
 	SIG_CHECK_PARAMS(sig, siginfo, context);
 
 	printf("Got signal [signal:%d(%s),reason:%d,refaddr:%p]. Crashing ...", \
 			sig, get_signal_name(sig), \
 			SIG_CHECKED_FIELD(siginfo, si_code), \
 			SIG_CHECKED_FIELD_TYPE(siginfo, si_addr, void *));
 }
 
 void fatal_signal_handler(int sig, siginfo_t *siginfo, void *context)
 {
+        NT_UNUSED(sig);
+        NT_UNUSED(siginfo);
+        NT_UNUSED(context);
 //	log_fatal_signal(sig, siginfo, context);
 //	nt_log_fatal_info(context, NT_FATAL_LOG_FULL_INFO);
 	exit_with_failure();
 }
 
 void	alarm_signal_handler(int sig, siginfo_t *siginfo, void *context)
 {
 	SIG_CHECK_PARAMS(sig, siginfo, context);
 
 	nt_alarm_flag_set();	/* set alarm flag */
 }
 
 void	nt_set_common_signal_handlers(void)
 {
 	struct sigaction	phan;
 
 	sig_parent_pid = (int)getpid();
 
 	sigemptyset(&phan.sa_mask);
 	phan.sa_flags = SA_SIGINFO;
 
 	phan.sa_sigaction = terminate_signal_handler;
 	sigaction(SIGINT, &phan, NULL);
 	sigaction(SIGQUIT, &phan, NULL);
 	sigaction(SIGTERM, &phan, NULL);
diff --git a/version.c b/version.c
index b25d1c85de1c6bcb31bacdcf54c8990a51a3cf22..5a273f9dc7920fd7f3dbab104eb1102ebd69a62c 100644
--- a/version.c
+++ b/version.c
@@ -1,40 +1,40 @@
 /*
 ** Copyright (C) 2001-2025 Nt SIA
 **
 ** This program is free software: you can redistribute it and/or modify it under the terms of
 ** the GNU Affero General Public License as published by the Free Software Foundation, version 3.
 **
 ** This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 ** without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 ** See the GNU Affero General Public License for more details.
 **
 ** You should have received a copy of the GNU Affero General Public License along with this program.
 ** If not, see <https://www.gnu.org/licenses/>.
 **/
 
-#include "nt_version.h"
+#include "version.h"
 #include "nt_types.h"
 #include "common.h"
 
 /******************************************************************************
  *                                                                            *
  * Purpose: Extracts protocol version from string cont. Alphanumeric release  *
  *          candidate version part is ignored.                                *
  *                                                                            *
  * Parameters:                                                                *
  *     version_str - [IN] textual representation of version                   *
  *                   Example: "6.4.0alpha1", "6.4.0" or "6.4"                 *
  *                                                                            *
  * Return value: The protocol version if it was successfully extracted,       *
  *               otherwise FAIL                                               *
  *                                                                            *
  ******************************************************************************/
 int	nt_get_component_version(const char *version_str)
 {
 	char	*pmid, *plow;
 	char	version_buf[NT_VERSION_BUF_LEN];
 
 	nt_strlcpy(version_buf, version_str, sizeof(version_buf));
 
 	if (NULL == (pmid = strchr(version_buf, '.')))
 		return FAIL;
diff --git a/version.h b/version.h
index 6799a78b235822953a724937747732b4b5403e21..14208c3efaa1e699daabbf51bcd02e2e4eda12df 100644
--- a/version.h
+++ b/version.h
@@ -1,27 +1,32 @@
 #ifndef NT_VERSION_H
 #define NT_VERSION_H
 
-#define NT_STR2(str)	#str
-#define NT_STR(str)	NT_STR2(str)
+#define NT_STR2(str)    #str
+#define NT_STR(str)     NT_STR2(str)
 
-#define APPLICATION_NAME	"Nt Agent"
-#define NT_REVDATE		"22 October 2025"
-#define NT_VERSION_MAJOR	7
-#define NT_VERSION_MINOR	4
-#define NT_VERSION_PATCH	4
+#define APPLICATION_NAME        "Nt Agent"
+#define NT_REVDATE              "22 October 2025"
+#define NT_VERSION_MAJOR        7
+#define NT_VERSION_MINOR        4
+#define NT_VERSION_PATCH        4
+#define NT_VERSION_BUF_LEN      64
 #ifndef NT_VERSION_REVISION
-#	define NT_VERSION_REVISION	{NT_REVISION}
+#       define NT_VERSION_REVISION      {NT_REVISION}
 #endif
 #ifdef _WINDOWS
-#	ifndef NT_VERSION_RC_NUM
-#		define NT_VERSION_RC_NUM	{NT_RC_NUM}
-#	endif
+#       ifndef NT_VERSION_RC_NUM
+#               define NT_VERSION_RC_NUM        {NT_RC_NUM}
+#       endif
 #endif
-#define NT_VERSION_RC	"rc1"
-#define NT_VERSION		NT_STR(NT_VERSION_MAJOR) "." NT_STR(NT_VERSION_MINOR) "." \
-				NT_STR(NT_VERSION_PATCH) NT_VERSION_RC
-#define NT_VERSION_SHORT	NT_STR(NT_VERSION_MAJOR) "." NT_STR(NT_VERSION_MINOR) "." \
-				NT_STR(NT_VERSION_PATCH)
-#define NT_REVISION		NT_STR(NT_VERSION_REVISION)
+#define NT_VERSION_RC   "rc1"
+#define NT_VERSION              NT_STR(NT_VERSION_MAJOR) "." NT_STR(NT_VERSION_MINOR) "." \
+                                NT_STR(NT_VERSION_PATCH) NT_VERSION_RC
+#define NT_VERSION_SHORT        NT_STR(NT_VERSION_MAJOR) "." NT_STR(NT_VERSION_MINOR) "." \
+                                NT_STR(NT_VERSION_PATCH)
+#define NT_REVISION             NT_STR(NT_VERSION_REVISION)
 
-#endif /* NT_VERSION_H */
\ No newline at end of file
+#define NT_COMPONENT_VERSION(major, minor, patch) \
+                                (((major) << 16) | ((minor) << 8) | (patch))
+#define NT_COMPONENT_VERSION_WITHOUT_PATCH(ver)    ((ver) & ~0xFF)
+
+#endif /* NT_VERSION_H */

